/**
 * @title 必须先订阅再发布吗
 *
 * todo: 把DOM事件的情况一会写上
 * 我们所了解到的发布-订阅模式，都是订阅者先订阅一个消息（事件），随后才能收到发布者的消息。
 * 如果把顺序反过来，发布者先发布一条消息，而在此之前并没有订阅者来订阅它，这条消息无疑将消失在宇宙中。
 *
 * 在某些情况下，我们需要先将这条消息（发布者触发的消息）保存下来，等有对象订阅它的时候，再重新把消息发给订阅者。
 * 就如同 QQ 中的离线消息一样，离线消息被保存在服务器中，接收人下次登录上线之后，可以重新接收这条消息。
 *
 * 在之前的商城网站中，获取用户信息之后才能渲染用户导航模块，而获取用户信息是一个 ajax 异步请求。当 ajax 请求成功返回之后会发布一个事件
 * ，在此之前订阅了此事件的用户导航模块可以接收到这些用户信息。
 *
 * 但这只是理想情况，因为异步的原因，不能保证 ajax 请求返回的时间，有时候返回的快，而此时用户导航模块的代码还没加载好（还没订阅响应事件）
 * 特是在用了一些懒加载技术后，这是很可能发送的事。也行我们还需要一个方案，使得我们的发布-订阅对象拥有先发布后订阅的能力。
 */

/**
 * todo: 堆栈？
 * 为了满足这个需求，我们要建立一个存放「离线事件」的堆栈，当事件发布，如果此时还没有订阅者订阅这个事件，
 * 我们暂时把这个事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，
 * 我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当前离线事件的生命周期只有依次，
 * 就像 QQ 的未读消息只会被重新阅读一次，所有刚才的操作我们只进行一次。
 */

/**
 * @title 全局事件的命名冲突
 * 全局的发布-订阅对象里只有一个 clientList 来存放消息名和回调函数，大家都通过它来订阅和发布各种消息，久而久之，难免会出现事件名冲突的情况,
 * 所以我们还可以给 Event 对象提供全局`命名空间`的功能。
 */

/**================================== 使用这两个新功能 **/

/********* 先发布、后订阅 *********/
_Event.trigger('click', 1);

_Event.listen('click', (data) => {
  console.log('--收到', data);
});

/********* 使用命名空间 *********/
_Event.create('GE-Click').listen('click', (data) => {
  console.log('ge 空间', data);
});
_Event.create('GE-Click').trigger('click', 1);

_Event.create('GM-Click').listen('click', (data) => {
  console.log('--GM 空间', data);
});
_Event.create('GM-Click').trigger('click', 2);
